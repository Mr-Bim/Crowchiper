import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { transform } from "lightningcss";

/**
 * Generate unique 2-letter class names (a-z only)
 * Returns a generator that yields unique names: aa, ab, ac, ..., zz
 */
function* generateClassNames() {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  for (let i = 0; i < chars.length; i++) {
    for (let j = 0; j < chars.length; j++) {
      yield chars[i] + chars[j];
    }
  }
}

/**
 * Extract all class names from CSS content
 * Matches class selectors like .class-name
 */
export function extractClassNames(css) {
  const classRegex = /\.([a-zA-Z_-][a-zA-Z0-9_-]*)/g;
  const classes = new Set();
  for (const match of css.matchAll(classRegex)) {
    classes.add(match[1]);
  }
  return classes;
}

/**
 * Extract all id attributes from HTML content
 * Matches id="my-id" attributes
 */
function extractIdsFromHtml(html) {
  const idRegex = /\bid="([^"]*)"/g;
  const ids = new Set();
  for (const match of html.matchAll(idRegex)) {
    ids.add(match[1]);
  }
  return ids;
}

/**
 * Extract all data-testid attributes from HTML content
 * Matches data-testid="my-testid" attributes
 */
function extractTestIdsFromHtml(html) {
  const testIdRegex = /\bdata-testid="([^"]*)"/g;
  const testIds = new Set();
  for (const match of html.matchAll(testIdRegex)) {
    testIds.add(match[1]);
  }
  return testIds;
}

/**
 * Find overlap between HTML IDs and CSS class names.
 * This is problematic because minified class names could collide with IDs.
 * @param {string} html - HTML content
 * @param {string} css - CSS content
 * @returns {Set<string>} Set of names that appear as both HTML IDs and CSS classes
 */
function findIdClassOverlap(html, css) {
  const htmlIds = extractIdsFromHtml(html);
  const cssClasses = extractClassNames(css);
  const overlap = new Set();
  for (const id of htmlIds) {
    if (cssClasses.has(id)) {
      overlap.add(id);
    }
  }
  return overlap;
}

/**
 * Find overlap between data-testid values and CSS class names.
 * This is problematic because minified class names could collide with testids in JS.
 * @param {string} html - HTML content
 * @param {string} css - CSS content
 * @returns {Set<string>} Set of names that appear as both data-testid values and CSS classes
 */
function findTestIdClassOverlap(html, css) {
  const testIds = extractTestIdsFromHtml(html);
  const cssClasses = extractClassNames(css);
  const overlap = new Set();
  for (const testId of testIds) {
    if (cssClasses.has(testId)) {
      overlap.add(testId);
    }
  }
  return overlap;
}

/**
 * Extract all class names from HTML content
 * Matches class="foo bar" attributes and extracts individual class names
 */
function extractClassesFromHtml(html) {
  const classAttrRegex = /\bclass="([^"]*)"/g;
  const classes = new Set();
  for (const match of html.matchAll(classAttrRegex)) {
    const classValue = match[1];
    for (const className of classValue.split(/\s+/)) {
      if (className) {
        classes.add(className);
      }
    }
  }
  return classes;
}

/**
 * Find HTML classes that don't exist in CSS.
 * @param {string} html - HTML content
 * @param {string} css - CSS content
 * @param {Set<string>} sharedClasses - Classes from shared styles.css (not in inlined CSS)
 * @returns {Set<string>} Set of HTML classes not found in CSS
 */
function findOrphanedHtmlClasses(html, css, sharedClasses) {
  const htmlClasses = extractClassesFromHtml(html);
  const cssClasses = extractClassNames(css);
  const orphaned = new Set();
  for (const className of htmlClasses) {
    if (!cssClasses.has(className) && !sharedClasses.has(className)) {
      orphaned.add(className);
    }
  }
  return orphaned;
}

/**
 * Minify class names in CSS and HTML
 * @param {string} css - CSS content
 * @param {string} html - HTML content
 * @param {Set<string>} excludeClasses - Class names to exclude from minification
 * @returns {{css: string, html: string, classMap: Map<string, string>}}
 */
function minifyClassNames(css, html, excludeClasses = new Set()) {
  const classNames = extractClassNames(css);
  const nameGen = generateClassNames();
  const classMap = new Map();

  // Build mapping of original -> minified names (excluding shared classes)
  for (const className of classNames) {
    // Skip classes that exist in styles.css (shared styles)
    if (excludeClasses.has(className)) {
      continue;
    }
    // Skip classes starting with "cm-" (CodeMirror classes generated by the library)
    if (className.startsWith("cm-")) {
      continue;
    }
    const minified = nameGen.next().value;
    if (!minified) {
      throw new Error("Ran out of class names (max 676)");
    }
    classMap.set(className, minified);
  }

  // Replace in CSS: .original-class -> .ab
  let minifiedCss = css;
  for (const [original, minified] of classMap) {
    // Match class selector, being careful about boundaries
    const cssRegex = new RegExp(
      `\\.${original.replace(/[-]/g, "\\-")}(?=[^a-zA-Z0-9_-]|$)`,
      "g",
    );
    minifiedCss = minifiedCss.replace(cssRegex, `.${minified}`);
  }

  // Replace in HTML: class="original-class" -> class="ab"
  let minifiedHtml = html;
  // Match class attributes and replace class names within them
  minifiedHtml = minifiedHtml.replace(/\bclass="([^"]*)"/g, (_, classValue) => {
    const classes = classValue.split(/\s+/);
    const minifiedClasses = classes.map((c) => classMap.get(c) || c);
    return `class="${minifiedClasses.join(" ")}"`;
  });

  return { css: minifiedCss, html: minifiedHtml, classMap };
}

/**
 * Replace class names in JavaScript content
 * @param {string} js - JS content
 * @param {Map<string, string>} classMap - Map of original -> minified class names
 * @returns {string} Minified JS content
 */
function minifyJsClassNames(js, classMap) {
  let minifiedJs = js;
  for (const [original, minified] of classMap) {
    minifiedJs = minifiedJs.replaceAll(`"${original}"`, `"${minified}"`);
    minifiedJs = minifiedJs.replaceAll(`'${original}'`, `'${minified}'`);
    minifiedJs = minifiedJs.replaceAll(`\`${original}\``, `\`${minified}\``);

    minifiedJs = minifiedJs.replace(/(["'`])(?:(?=(\\?))\2.)*?\1/g, (match) => {
      const quote = match[0];
      const content = match.slice(1, -1);

      const parts = content.split(/(\s+)/);
      let changed = false;
      const newParts = parts.map((part) => {
        if (classMap.has(part)) {
          changed = true;
          return classMap.get(part);
        }
        return part;
      });

      if (changed) {
        return `${quote}${newParts.join("")}${quote}`;
      }
      return match;
    });
  }
  return minifiedJs;
}

/**
 * Minify and copy styles.css to dist, returning the set of shared class names
 * @param {string} rootDir - Project root directory
 * @param {string} distDir - Distribution directory
 * @returns {Set<string>} Set of class names from styles.css
 */
export function processSharedStyles(rootDir, distDir) {
  const stylesPath = join(rootDir, "web", "styles.css");
  const stylesDistPath = join(distDir, "styles.css");
  let sharedClasses = new Set();

  if (existsSync(stylesPath)) {
    const stylesContent = readFileSync(stylesPath, "utf-8");
    sharedClasses = extractClassNames(stylesContent);
    const { code } = transform({
      filename: "styles.css",
      code: Buffer.from(stylesContent),
      minify: true,
    });
    writeFileSync(stylesDistPath, code);
    console.log(`✓ Minified styles.css`);
  }

  return sharedClasses;
}

/**
 * Process CSS minification for an HTML file
 * @param {Object} options
 * @param {string} options.html - HTML content
 * @param {string} options.inlinedCss - CSS content to minify
 * @param {string} options.filename - HTML filename for error messages
 * @param {Set<string>} options.sharedClasses - Classes from shared styles.css
 * @param {string} options.distDir - Distribution directory
 * @param {boolean} options.testMode - Whether test mode is enabled
 * @returns {{html: string, css: string, classMap: Map<string, string>}}
 */
export function processCssMinification({
  html,
  inlinedCss,
  filename,
  sharedClasses,
  testMode,
}) {
  if (!inlinedCss) {
    return { html, css: "", classMap: new Map() };
  }

  // Check for overlap between HTML IDs and CSS class names
  const idClassOverlap = findIdClassOverlap(html, inlinedCss);
  if (idClassOverlap.size > 0) {
    console.warn(
      `⚠ Warning: Found overlap between HTML IDs and CSS class names in ${filename}:`,
    );
    console.warn(`  Overlapping names: ${[...idClassOverlap].join(", ")}`);
    throw new Error(
      "Skipping build: CSS class minification would break getElementById calls.",
    );
  }

  // In test mode, check for overlap between data-testid values and CSS class names
  if (testMode) {
    const testIdClassOverlap = findTestIdClassOverlap(html, inlinedCss);
    if (testIdClassOverlap.size > 0) {
      console.warn(
        `⚠ Warning: Found overlap between data-testid values and CSS class names in ${filename}:`,
      );
      console.warn(
        `  Overlapping names: ${[...testIdClassOverlap].join(", ")}`,
      );
      throw new Error(
        "Skipping build: CSS class minification would break data-testid selectors.",
      );
    }
  }

  const {
    css,
    html: minifiedHtml,
    classMap,
  } = minifyClassNames(inlinedCss, html, sharedClasses);

  // Warn about HTML classes that don't exist in CSS
  const orphanedClasses = findOrphanedHtmlClasses(
    minifiedHtml,
    css,
    sharedClasses,
  );
  if (orphanedClasses.size > 0) {
    console.warn(
      `⚠ Warning: Found HTML classes not defined in CSS in ${filename}:`,
    );
    console.warn(`  Orphaned classes: ${[...orphanedClasses].join(", ")}`);
  }

  return { html: minifiedHtml, css, classMap };
}

export { minifyJsClassNames };
