import { createHash } from "node:crypto";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { transform } from "lightningcss";

/**
 * Generate unique 2-letter class names (a-z only)
 * Returns a generator that yields unique names: aa, ab, ac, ..., zz
 */
function* generateClassNames() {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  for (let i = 0; i < chars.length; i++) {
    for (let j = 0; j < chars.length; j++) {
      yield chars[i] + chars[j];
    }
  }
}

/**
 * Extract all class names from CSS content
 * Matches class selectors like .class-name
 */
export function extractClassNames(css) {
  // First, remove url(...) content to avoid matching .w3 in www.w3.org etc.
  const cssWithoutUrls = css.replace(/url\([^)]*\)/g, "url()");

  const classRegex = /\.([a-zA-Z_-][a-zA-Z0-9_-]*)/g;
  const classes = new Set();
  for (const match of cssWithoutUrls.matchAll(classRegex)) {
    classes.add(match[1]);
  }
  return classes;
}

/**
 * Extract all id attributes from HTML content
 * Matches id="my-id" attributes
 */
function extractIdsFromHtml(html) {
  const idRegex = /\bid="([^"]*)"/g;
  const ids = new Set();
  for (const match of html.matchAll(idRegex)) {
    ids.add(match[1]);
  }
  return ids;
}

/**
 * Extract all data-testid attributes from HTML content
 * Matches data-testid="my-testid" attributes
 */
function extractTestIdsFromHtml(html) {
  const testIdRegex = /\bdata-testid="([^"]*)"/g;
  const testIds = new Set();
  for (const match of html.matchAll(testIdRegex)) {
    testIds.add(match[1]);
  }
  return testIds;
}

/**
 * Find overlap between HTML IDs and CSS class names.
 * This is problematic because minified class names could collide with IDs.
 * @param {string} html - HTML content
 * @param {string} css - CSS content
 * @returns {Set<string>} Set of names that appear as both HTML IDs and CSS classes
 */
function findIdClassOverlap(html, css) {
  const htmlIds = extractIdsFromHtml(html);
  const cssClasses = extractClassNames(css);
  const overlap = new Set();
  for (const id of htmlIds) {
    if (cssClasses.has(id)) {
      overlap.add(id);
    }
  }
  return overlap;
}

/**
 * Find overlap between data-testid values and CSS class names.
 * This is problematic because minified class names could collide with testids in JS.
 * @param {string} html - HTML content
 * @param {string} css - CSS content
 * @returns {Set<string>} Set of names that appear as both data-testid values and CSS classes
 */
function findTestIdClassOverlap(html, css) {
  const testIds = extractTestIdsFromHtml(html);
  const cssClasses = extractClassNames(css);
  const overlap = new Set();
  for (const testId of testIds) {
    if (cssClasses.has(testId)) {
      overlap.add(testId);
    }
  }
  return overlap;
}

/**
 * Extract all class names from HTML content
 * Matches class="foo bar" attributes and extracts individual class names
 */
function extractClassesFromHtml(html) {
  const classAttrRegex = /\bclass="([^"]*)"/g;
  const classes = new Set();
  for (const match of html.matchAll(classAttrRegex)) {
    const classValue = match[1];
    for (const className of classValue.split(/\s+/)) {
      if (className) {
        classes.add(className);
      }
    }
  }
  return classes;
}

/**
 * Find HTML classes that don't exist in CSS.
 * @param {string} html - HTML content
 * @param {string} css - CSS content
 * @param {Set<string>} sharedClasses - Classes from shared styles.css (not in inlined CSS)
 * @returns {Set<string>} Set of HTML classes not found in CSS
 */
function findOrphanedHtmlClasses(html, css, sharedClasses) {
  const htmlClasses = extractClassesFromHtml(html);
  const cssClasses = extractClassNames(css);
  const orphaned = new Set();
  for (const className of htmlClasses) {
    if (!cssClasses.has(className) && !sharedClasses.has(className)) {
      orphaned.add(className);
    }
  }
  return orphaned;
}

/**
 * Minify class names in CSS and HTML
 * @param {string} css - CSS content
 * @param {string} html - HTML content
 * @param {Set<string>} excludeClasses - Class names to exclude from minification
 * @returns {{css: string, html: string, classMap: Map<string, string>}}
 */
function minifyClassNames(css, html, excludeClasses = new Set()) {
  const classNames = extractClassNames(css);
  const nameGen = generateClassNames();
  const classMap = new Map();

  // Build mapping of original -> minified names (excluding shared classes)
  for (const className of classNames) {
    // Skip classes that exist in styles.css (shared styles)
    if (excludeClasses.has(className)) {
      continue;
    }
    // Skip classes starting with "cm-" (CodeMirror classes generated by the library)
    if (className.startsWith("cm-")) {
      continue;
    }
    const minified = nameGen.next().value;
    if (!minified) {
      throw new Error("Ran out of class names (max 676)");
    }
    classMap.set(className, minified);
  }

  // Replace in CSS: .original-class -> .ab
  let minifiedCss = css;
  for (const [original, minified] of classMap) {
    // Match class selector, being careful about boundaries
    const cssRegex = new RegExp(
      `\\.${original.replace(/[-]/g, "\\-")}(?=[^a-zA-Z0-9_-]|$)`,
      "g",
    );
    minifiedCss = minifiedCss.replace(cssRegex, `.${minified}`);
  }

  // Replace in HTML: class="original-class" -> class="ab"
  let minifiedHtml = html;
  // Match class attributes and replace class names within them
  minifiedHtml = minifiedHtml.replace(/\bclass="([^"]*)"/g, (_, classValue) => {
    const classes = classValue.split(/\s+/);
    const minifiedClasses = classes.map((c) => classMap.get(c) || c);
    return `class="${minifiedClasses.join(" ")}"`;
  });

  return { css: minifiedCss, html: minifiedHtml, classMap };
}

/**
 * Replace class names in JavaScript content
 * @param {string} js - JS content
 * @param {Map<string, string>} classMap - Map of original -> minified class names
 * @returns {string} Minified JS content
 */
function minifyJsClassNames(js, classMap) {
  // Build a regex that matches all class names in quoted strings
  // Pattern: (quote)(optional dot)(className)(quote) where quotes must match
  const escapedNames = [...classMap.keys()].map((name) =>
    name.replace(/[-]/g, "\\-"),
  );
  const namesPattern = escapedNames.join("|");
  // Match: "className", ".className", 'className', '.className', `className`, `.className`
  const exactMatchRegex = new RegExp(`(["'\`])(\\.?)(${namesPattern})\\1`, "g");

  let minifiedJs = js.replace(exactMatchRegex, (_, quote, dot, className) => {
    const minified = classMap.get(className);
    return minified ? `${quote}${dot}${minified}${quote}` : _;
  });

  // Helper to replace class names in space-separated content
  // Only process content that looks like CSS class names (no URLs, paths, etc.)
  function replaceInContent(content) {
    if (!/\s/.test(content)) {
      return null; // No whitespace, skip
    }

    // Skip if it looks like a URL, path, or other non-class content
    if (
      content.includes("://") ||
      content.includes("/") ||
      content.includes("\\") ||
      content.includes("@") ||
      content.includes("=") ||
      content.includes(":") ||
      content.includes("(") ||
      content.includes(")")
    ) {
      return null;
    }

    const parts = content.split(/(\s+)/);
    let changed = false;
    const newParts = parts.map((part) => {
      if (part.startsWith(".") && classMap.has(part.slice(1))) {
        changed = true;
        return "." + classMap.get(part.slice(1));
      }
      if (classMap.has(part)) {
        changed = true;
        return classMap.get(part);
      }
      return part;
    });

    return changed ? newParts.join("") : null;
  }

  // Second pass: handle space-separated class names in strings
  // Process each quote type separately to avoid cross-matching issues
  // Double quotes
  minifiedJs = minifiedJs.replace(/"([^"]*)"/g, (match, content) => {
    const replaced = replaceInContent(content);
    return replaced !== null ? `"${replaced}"` : match;
  });

  // Single quotes
  minifiedJs = minifiedJs.replace(/'([^']*)'/g, (match, content) => {
    const replaced = replaceInContent(content);
    return replaced !== null ? `'${replaced}'` : match;
  });

  // Backticks (template literals without interpolation)
  minifiedJs = minifiedJs.replace(/`([^`]*)`/g, (match, content) => {
    const replaced = replaceInContent(content);
    return replaced !== null ? `\`${replaced}\`` : match;
  });

  return minifiedJs;
}

/**
 * Minify and copy styles.css to dist/assets/ with content hash, returning the set of shared class names
 * @param {string} rootDir - Project root directory
 * @param {string} distDir - Distribution directory
 * @returns {{sharedClasses: Set<string>, hashedFilename: string|null}} Set of class names and hashed filename
 */
export function processSharedStyles(rootDir, distDir) {
  const stylesPath = join(rootDir, "web", "styles.css");
  let sharedClasses = new Set();
  let hashedFilename = null;

  if (existsSync(stylesPath)) {
    const stylesContent = readFileSync(stylesPath, "utf-8");
    sharedClasses = extractClassNames(stylesContent);
    const { code } = transform({
      filename: "styles.css",
      code: Buffer.from(stylesContent),
      minify: true,
    });

    // Generate content hash (first 8 chars of SHA-256)
    const hash = createHash("sha256").update(code).digest("hex").slice(0, 8);
    hashedFilename = `styles-${hash}.css`;

    // Ensure assets directory exists
    const assetsDir = join(distDir, "assets");
    mkdirSync(assetsDir, { recursive: true });

    writeFileSync(join(assetsDir, hashedFilename), code);
    console.log(`✓ Minified styles.css -> assets/${hashedFilename}`);
  }

  return { sharedClasses, hashedFilename };
}

/**
 * Process CSS minification for an HTML file
 * @param {Object} options
 * @param {string} options.html - HTML content
 * @param {string} options.inlinedCss - CSS content to minify
 * @param {string} options.filename - HTML filename for error messages
 * @param {Set<string>} options.sharedClasses - Classes from shared styles.css
 * @param {string} options.distDir - Distribution directory
 * @param {boolean} options.testMode - Whether test mode is enabled
 * @returns {{html: string, css: string, classMap: Map<string, string>}}
 */
export function processCssMinification({
  html,
  inlinedCss,
  filename,
  sharedClasses,
  testMode,
}) {
  if (!inlinedCss) {
    return { html, css: "", classMap: new Map() };
  }

  // Check for overlap between HTML IDs and CSS class names
  const idClassOverlap = findIdClassOverlap(html, inlinedCss);
  if (idClassOverlap.size > 0) {
    console.warn(
      `⚠ Warning: Found overlap between HTML IDs and CSS class names in ${filename}:`,
    );
    console.warn(`  Overlapping names: ${[...idClassOverlap].join(", ")}`);
    throw new Error(
      "Skipping build: CSS class minification would break getElementById calls.",
    );
  }

  // In test mode, check for overlap between data-testid values and CSS class names
  if (testMode) {
    const testIdClassOverlap = findTestIdClassOverlap(html, inlinedCss);
    if (testIdClassOverlap.size > 0) {
      console.warn(
        `⚠ Warning: Found overlap between data-testid values and CSS class names in ${filename}:`,
      );
      console.warn(
        `  Overlapping names: ${[...testIdClassOverlap].join(", ")}`,
      );
      throw new Error(
        "Skipping build: CSS class minification would break data-testid selectors.",
      );
    }
  }

  const {
    css,
    html: minifiedHtml,
    classMap,
  } = minifyClassNames(inlinedCss, html, sharedClasses);

  // Warn about HTML classes that don't exist in CSS
  const orphanedClasses = findOrphanedHtmlClasses(
    minifiedHtml,
    css,
    sharedClasses,
  );
  if (orphanedClasses.size > 0) {
    console.warn(
      `⚠ Warning: Found HTML classes not defined in CSS in ${filename}:`,
    );
    console.warn(`  Orphaned classes: ${[...orphanedClasses].join(", ")}`);
  }

  return { html: minifiedHtml, css, classMap };
}

export { minifyJsClassNames };
